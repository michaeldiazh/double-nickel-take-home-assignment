import {z} from 'zod';
import {QueryResult} from 'pg';
import {Conversation, SimplifiedConversation} from './domain';
import {simplifiedApplicationDomainKeyToTableKey} from '../application/database';
import {screeningDecisionSchema, ScreeningDecision} from '../enums';
import {KeyTranslator} from '../../services/filters/where-filter';

/**
 * Simplified conversation row shape - base fields in snake_case (includes id, excludes timestamps)
 * Database row equivalent of SimplifiedConversation
 */
export const simplifiedConversationRowShape = {
    id: z.uuidv4(),
    app_id: z.uuidv4(),
    is_active: z.boolean(),
    screening_decision: screeningDecisionSchema,
    screening_summary: z.string().nullable(),
    screening_reasons: z.record(z.string(), z.unknown()).nullable(),
    ended_at: z.date().nullable(),
};

/**
 * Simplified conversation row schema (snake_case, includes id, excludes timestamps)
 * Database row equivalent of SimplifiedConversation
 */
export const simplifiedConversationRowSchema = z.object(simplifiedConversationRowShape);

export type SimplifiedConversationRow = z.infer<typeof simplifiedConversationRowSchema>;

/**
 * Database row schema for conversation table (snake_case)
 * Used for validating data coming from the database
 */
export const conversationRowSchema = simplifiedConversationRowSchema.extend({
    created_at: z.date(),
    updated_at: z.date(),
});

export type ConversationRow = z.infer<typeof conversationRowSchema>;

export const conversationDomainKeyToTableKey: KeyTranslator<Conversation> = {
    id: 'id',
    isActive: 'is_active',
    screeningDecision: 'screening_decision',
    screeningSummary: 'screening_summary',
    screeningReasons: 'screening_reasons',
    endedAt: 'ended_at',
    application: simplifiedApplicationDomainKeyToTableKey,
    createdAt: 'created_at',
    updatedAt: 'updated_at',
};

export const simplifiedConversationDomainKeyToTableKey: KeyTranslator<SimplifiedConversation> = {
    id: 'id',
    appId: 'app_id',
    isActive: 'is_active',
    screeningDecision: 'screening_decision',
    screeningSummary: 'screening_summary',
    screeningReasons: 'screening_reasons',
    endedAt: 'ended_at',
};

/**
 * Database row schema for inserting a new conversation (snake_case)
 * Excludes id and timestamps which are generated by the database
 */
export const insertConversationRowSchema = z.object({
    app_id: z.uuidv4(),
    is_active: z.boolean().optional(),
    screening_decision: screeningDecisionSchema.optional(),
    screening_summary: z.string().nullable().optional(),
    screening_reasons: z.record(z.string(), z.unknown()).nullable().optional(),
    ended_at: z.date().nullable().optional(),
});

export type InsertConversationRow = z.infer<typeof insertConversationRowSchema>;

/**
 * Creates a new conversation in the database.
 * 
 * @param client - Database client (can be from a transaction or pool)
 * @param appId - The application ID this conversation belongs to
 * @returns The created conversation ID
 */
export const createConversation = async (
  client: { query: (text: string, values?: unknown[]) => Promise<QueryResult> },
  appId: string
): Promise<string> => {
  const query = `
    INSERT INTO conversation (id, app_id, is_active, screening_decision, screening_summary, screening_reasons, ended_at)
    VALUES (gen_random_uuid(), $1, $2, $3, $4, $5, $6)
    RETURNING id
  `;
  
  const insertData = insertConversationRowSchema.parse({
    app_id: appId,
    is_active: true,
    screening_decision: ScreeningDecision.PENDING,
    screening_summary: null,
    screening_reasons: null,
    ended_at: null,
  });
  
  const result: QueryResult<{ id: string }> = await client.query(query, [
    insertData.app_id,
    insertData.is_active,
    insertData.screening_decision,
    insertData.screening_summary,
    insertData.screening_reasons,
    insertData.ended_at,
  ]);
  
  return result.rows[0].id;
};

